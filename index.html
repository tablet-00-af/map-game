<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>コンパス探索ゲーム</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
  font-family: sans-serif;
  text-align: center;
  padding: 20px;
}
button, select {
  font-size: 16px;
  padding: 8px 16px;
  margin: 6px;
}
#compass {
  width: 220px;
  height: 220px;
  border: 3px solid black;
  border-radius: 50%;
  margin: 20px auto;
  position: relative;
}
#arrow {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 6px;
  height: 90px;
  transform-origin: center bottom;
  transform: translate(-50%, -100%) rotate(0deg);
}
#needle {
  width: 6px;
  height: 90px;
  background: black;
  position: relative;
}
#needle::after {
  content: "";
  position: absolute;
  top: -14px;
  left: -9px;
  width: 24px;
  height: 24px;
  background: red;
  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
}
#info {
  margin-top: 10px;
}
#result {
  font-size: 20px;
  font-weight: bold;
  margin-top: 15px;
}
</style>
</head>
<body>

<h2>コンパス探索ゲーム</h2>

<select id="mode">
  <option value="free">フリーモード</option>
  <option value="timeattack">タイムアタック</option>
  <option value="timelimit">タイムリミット</option>
</select>
<br>

<button onclick="startGame()">スタート</button>
<button onclick="arrive()">ここだ！</button>

<p id="status">未開始</p>

<div id="compass">
  <div id="arrow">
    <div id="needle"></div>
  </div>
</div>

<div id="info">
  <p id="distance">距離: - m</p>
  <p id="timer"></p>
  <p id="total"></p>
</div>

<p id="result"></p>

<script>
let targetPos, currentPos;
let deviceHeading = 0;
let watchId = null;

let smoothDiff = 0;
let gameState = "ready";
let gameMode = "free";

let startTime = 0;
let totalScore = 0;
const TIME_LIMIT = 600; // 10分

let lastGPS = 0;
let lastCompass = 0;

/* ===== スタート ===== */
function startGame() {
  if (gameState === "playing") return;

  gameMode = document.getElementById("mode").value;
  gameState = "playing";
  smoothDiff = 0;
  totalScore = 0;
  startTime = Date.now();

  document.getElementById("result").textContent = "";
  document.getElementById("status").textContent = "探索中…";
  document.getElementById("total").textContent = "";

  requestOrientation();

  navigator.geolocation.getCurrentPosition(pos => {
    targetPos = generateTarget(pos.coords.latitude, pos.coords.longitude);
    startWatch();
  });
}

/* ===== 到着 ===== */
function arrive() {
  if (gameState !== "playing" || !currentPos) return;

  const d = calcDistance(
    currentPos.lat, currentPos.lon,
    targetPos.lat, targetPos.lon
  );

  const score = Math.max(0, 100 - Math.floor(d / 10) * 10);

  /* フリー */
  if (gameMode === "free") {
    endGame(`距離 ${Math.round(d)}m / ${score}点`);
  }

  /* タイムアタック */
  if (gameMode === "timeattack") {
    if (score === 100) {
      const t = ((Date.now() - startTime) / 1000).toFixed(1);
      endGame(`成功！ タイム ${t} 秒`);
    } else {
      endGame(`失敗… ${score}点`);
    }
  }

  /* タイムリミット */
  if (gameMode === "timelimit") {
    totalScore += score;
    document.getElementById("total").textContent =
      `合計スコア: ${totalScore}`;

    targetPos = generateTarget(currentPos.lat, currentPos.lon);
  }
}

/* ===== 終了 ===== */
function endGame(msg) {
  gameState = "end";
  navigator.geolocation.clearWatch(watchId);
  document.getElementById("status").textContent = "ゲーム終了";
  document.getElementById("result").textContent = msg;
}

/* ===== コンパス許可 ===== */
function requestOrientation() {
  if (DeviceOrientationEvent?.requestPermission) {
    DeviceOrientationEvent.requestPermission().then(res => {
      if (res === "granted")
        window.addEventListener("deviceorientation", handleOrientation);
    });
  } else {
    window.addEventListener("deviceorientation", handleOrientation);
  }
}

/* ===== 向き取得（30fps） ===== */
function handleOrientation(e) {
  const now = Date.now();
  if (now - lastCompass < 33) return;
  lastCompass = now;

  if (e.webkitCompassHeading !== undefined)
    deviceHeading = e.webkitCompassHeading;
  else if (e.alpha !== null)
    deviceHeading = 360 - e.alpha;
}

/* ===== 位置追跡（20fps） ===== */
function startWatch() {
  watchId = navigator.geolocation.watchPosition(pos => {
    if (gameState !== "playing") return;

    const now = Date.now();
    if (now - lastGPS < 50) return;
    lastGPS = now;

    currentPos = {
      lat: pos.coords.latitude,
      lon: pos.coords.longitude
    };

    const d = calcDistance(
      currentPos.lat, currentPos.lon,
      targetPos.lat, targetPos.lon
    );

    document.getElementById("distance").textContent =
      gameMode === "free" ? `距離: ${Math.round(d)} m` : "";

    if (gameMode !== "free") {
      const t = Math.floor((Date.now() - startTime) / 1000);
      document.getElementById("timer").textContent =
        gameMode === "timeattack"
          ? `経過: ${t}s`
          : `残り: ${Math.max(0, TIME_LIMIT - t)}s`;

      if (gameMode === "timelimit" && t >= TIME_LIMIT) {
        endGame(`時間切れ！ 合計 ${totalScore}点`);
      }
    }

    const bearing = calcBearing(
      currentPos.lat, currentPos.lon,
      targetPos.lat, targetPos.lon
    );

    let diff = ((bearing - deviceHeading + 540) % 360) - 180;
    if (Math.abs(diff) < 2) diff = 0;

    const abs = Math.abs(diff);
    const factor = abs > 60 ? 0.9 : abs > 20 ? 0.6 : 0.35;
    smoothDiff += (diff - smoothDiff) * factor;

    document.getElementById("arrow").style.transform =
      `translate(-50%, -100%) rotate(${smoothDiff}deg)`;
  });
}

/* ===== マーカー生成 ===== */
function generateTarget(lat, lon) {
  const d = 300 + Math.random() * 300;
  const a = Math.random() * 2 * Math.PI;
  return {
    lat: lat + (d * Math.cos(a)) / 111000,
    lon: lon + (d * Math.sin(a)) /
      (111000 * Math.cos(lat * Math.PI / 180))
  };
}

/* ===== 距離 ===== */
function calcDistance(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const toRad = x => x * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat/2)**2 +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

/* ===== 方角 ===== */
function calcBearing(lat1, lon1, lat2, lon2) {
  const toRad = x => x * Math.PI / 180;
  const toDeg = x => x * 180 / Math.PI;
  const dLon = toRad(lon2 - lon1);
  const y = Math.sin(dLon) * Math.cos(toRad(lat2));
  const x =
    Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
    Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
  return (toDeg(Math.atan2(y, x)) + 360) % 360;
}
</script>

</body>
</html>
